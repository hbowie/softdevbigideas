Title	Tags	Link	Body
Always Remember that Software Development is an Adventure			There are a great many who have tried to turn software development into a repeatable process. However each new project is like a new book from a favorite author: you expect some recurring elements, but if there's nothing new, then you have to wonder why it's worth the effort. So there is always an element of mystery, an element of surprise, in any good software development project -- if there isn't, then you're probably doing it wrong!
Cohesion			When performing decomposition, elements that are closely related to each other should be grouped together. The relationships may be based on functional similarities, communication paths between elements, and/or interdependencies. One test of cohesion is whether the function of a group can be easily described and understood, and whether the elements in that group can be seen to readily fit within that stated function. Be careful, though, not to group elements together based on a shared or similar role, if each element is tasked to perform that role for different groups. In other words, and in the case of development teams, you would not normally maximize cohesion by assigning each database analyst to a group of other database analysts, since the primary communication for each would be with the developers they are supporting, and not with other DBAs. Instead, groups of individuals performing similar roles on different teams can best communicate with each other as members of a Community of Practice. Such a group may also be referred to as a guild. 
Decomposition			Large and complex things should be broken down into smaller, more manageable things. This can be done progressively, and recursively, at multiple levels of decomposition. It's best if the number of things in each group is somewhere in the range of 3 - 15, with 7 being a sweet spot. The human brain seems fairly good at dealing with sets of this size. This idea can be applied to system functionality, to software architectures, to project plans (where it results in a work breakdown structure), and to project teams.
Introduction			I've spent four plus decades doing software development, and over that period I've read a long series of books, articles and blogs on the topic. And, of course, the number of new words written on the topic increases daily. How can a software developer keep up? I'm a firm believer that new ideas are generated from time to time, and that it is worthwhile to read about software development as well as to do it; on the other hand, I am also beginning to suspect that the number of distinctly different ideas is not that large, and that much of what's written consists of old ideas dressed up in the fashions of the day. And so I am setting off to test my hypothesis by trying to document the Big Ideas in Software Development in a concrete, manageable, sequential list. I'll be creating, refining and enhancing this list in public, at SoftDevBigIdeas.org, and I welcome you to follow along as I progress, and to submit your own occasional suggestions for additions and refinements. Since I'm focused here on Software Development, ideas that are more broadly applicable to other types of product development will generally be stated in software-centric terms, although this is not meant to deny or devalue their broader applicability. — or — I have been practicing software development for more than four decades now, and over that time, in addition to writing a lot of code, and being involved in a lot of projects in varying capacities, I've done a lot of reading on the topic. In fact, I've got shelves full of books on the topic, starting with classics like <cite>The Mythical Man Month</cite>, proceeding through the CMM period and then on into the Lean/Agile years. I'm now at the point, though, of wondering whether it wouldn't be possible to communicate the most important ideas about the field in a simpler, more concise, more easily accessible fashion. And thus was bred the idea for this site. My intent is to try to list, in ranked order, as many big ideas about software development as I can possibly capture. This will be an evolving public experiment, so check back frequently to see what's been added, and what's changed position, and be sure and let me know what you think is missing, misrepresented, or miscategorized. I look forward to your feedback.
Loose Coupling			When performing decomposition, it is best to group elements so as to minimize coupling between groups. Coupling can be thought of as communication between groups, or knowledge of what's going on within other groups, or dependencies of one group on another. Loose coupling tends to maximize the freedom of each group to handle its own work without consideration for what's going on in other groups. Note that loose coupling is desirable, whether the groups under consideration are teams of developers, or packages of data and methods. within agile, this idea results in the formation of relatively small, self-managed teams that contain all the resources they need to work relatively independently.
Shorten Feedback Loops			These can also be thought of as learning loops. Each loop should consist of [Plan-Do-Check-Act][pdca] steps. 1. Plan to do something (develop features, reduce defects, etc.) 2. Do the thing you planned. 3. Check the results. Did you meet your goals? 4. Take action, as needed, to accept your results into a new baseline, or to propose modifications to be input into the next Plan-Do-Check-Act (aka PDCA) cycle. Note that, in agile development, process feedback and action is considered during a retrospective, while product feedback and action are considered during a customer demo. In waterfall style development, it can take the entire length of your project to obtain feedback on your product and your processes. Agile, on the other hand, states as its third [principle][amp]: > Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale. These shorter timescales allow for frequent, iterative learning about customer requirements and preferences, product successes and shortcomings, as well as processes, tools and methods. [amp]:  http://agilemanifesto.org/principles.html [pdca]: https://en.wikipedia.org/wiki/PDCA
Show Rather than Tell			Language is a wonderful tool, but it is difficult for stakeholders to precisely parse large amounts of written text in order to provide reliable feedback on whether software developers are on the right track. On the other hand, diagrams, screen layouts, and prototypes are often easier for people to understand and respond to. This is not to say that words don't have their place. But interactive dialogue about a visual representation is often much more productive than shipping written text back and forth for review and approval. 
Software Developers Are Not Interchangeable			Aptitude, skills and experience all make a difference. Order-of-magnitude differences in productivity levels have been well documented. This is one reason why, as Fred Brooks pointed out long ago in the "Mythical Man-Month," estimates for software development can be entirely misleading. 
Stay Focused on the Creation of Working Software for Real People			This was a major message of the Agile movement, which opened its [Manifesto][am] with the words: "We are uncovering better ways of developing software by doing it and helping others do it." To a great deal, this was a reaction to the [Capability Maturity Model][cmm] era, which often overshadowed the actual act of software coding with an emphasis on maturity levels, key process areas, process documentation, generation of artifacts and production of metrics. The point here is that well-intentioned improvement efforts, whether initiated by management or by consultants, can all too easily prove a distraction to the actual production of working software to be used by real people, often to the detriment of everyone involved. [am]:  http://agilemanifesto.org [cmm]: https://en.wikipedia.org/wiki/Capability_Maturity_Model
Use the Best Tools Available			Software developers continue to develop better tools with which to do software development: better languages, better compilers, better source control, better task management... and the list goes on. Not everyone needs to develop new tools, and not everyone needs to be on the cutting edge of the latest advances, but you generally shouldn't fall too far behind the state of the art when it comes to development tools. 
Use Things Already Known to Work			In other words, don't reinvent the wheel. This can also be thought of as reuse. But there are a number of different ways to state this. 1. Don't spend good money creating something new when something sufficiently similar already exists. 2. Make use of patterns, algorithms, operating systems, APIs, services, database management systems, high-level languages, application frameworks, existing libraries and other building blocks that will help you focus on adding something new to the world, rather than simply recreating something that already exists. 3. If you find yourself or your team doing repetitive work, then try to encapsulate the repeated actions into a module, class, framework or subroutine that can be used when needed, rather than simply doing the same mindless coding again. Use of things already known to work is a great way to increase both productivity and quality. 
What's Not Done is as Important as What's Done			Sometimes the stuff you leave out is as important as the stuff you put in. Adding low-value or even unnecessary features not only wastes money spent on development, but adds to the complexity of the resulting product, making it harder to use and harder to maintain over the entire span of its remaining life. 
When Estimating, the Whole is Definitely Greater than the Sum of its Parts			The time needed to complete an entire project will always be greater than the sum of the estimates for completing the individual tasks. Why? 1. Some necessary tasks will not be included in your detailed estimates. 2. Estimates are usually based on the assumption that things will go well, and they often don't. 3. The time needed for communication and coordination is probably not included, and this work often increases exponentially as the entire project team size increases. 4. The time needed for requirements collection and analysis, design, testing and governance/compliance activities is often missing, or understated. 5. The time needed to bring new team members up to speed is often not included. 
